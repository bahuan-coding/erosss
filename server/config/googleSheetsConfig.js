// Usando imports compat√≠veis com Nuxt/Nitro para server-side
import { readFileSync } from 'node:fs'
import { resolve } from 'node:path'
import { google } from 'googleapis'

// Fun√ß√£o para inicializar a API do Google Sheets - tornando lazy-loaded para melhor compatibilidade
export function initializeGoogleSheets() {
  // Esta fun√ß√£o s√≥ ser√° executada no server-side (API routes)
  if (import.meta.server) {
    try {
      // Caminho para o arquivo de credenciais
      const CREDENTIALS_PATH = resolve(process.cwd(), 'server/config/google-credentials.json')
      
      console.log('üìÅ Caminho das credenciais:', CREDENTIALS_PATH);

      // Carrega as credenciais do arquivo
      let credentials;
      try {
        const credentialsContent = readFileSync(CREDENTIALS_PATH, 'utf8')
        console.log('üìÑ Arquivo de credenciais encontrado');
        
        credentials = JSON.parse(credentialsContent)
        
        // Verifica se as credenciais cont√™m as propriedades necess√°rias
        if (!credentials.client_email || !credentials.private_key) {
          console.error('‚ùå Arquivo de credenciais n√£o cont√©m client_email ou private_key');
          throw new Error('Credenciais inv√°lidas - campos essenciais ausentes');
        }
        
        // Corrigir um problema comum com a chave privada vinda de vari√°veis de ambiente
        // As quebras de linha podem ser codificadas como "\n" literal em vez de quebras reais
        if (credentials.private_key.includes('\\n') && !credentials.private_key.includes('\n')) {
          credentials.private_key = credentials.private_key.replace(/\\n/g, '\n');
          console.log('üîß Formata√ß√£o da chave privada corrigida (substituindo \\n)');
        }
        
        // Garantir que a chave privada tenha o formato correto, mesmo se j√° tiver \n
        // Este √© um problema comum com aspas no Windows, formata√ß√£o do arquivo etc.
        credentials.private_key = credentials.private_key
          .replace(/(?:\\r\\n|\\n|\\r)/g, '\n')  // Substituir qualquer representa√ß√£o de newline
          .replace(/\s+(?=-----END)/g, '\n');    // Garantir quebra antes do END

        console.log('üîß Chave privada processada para garantir formato correto');
        
        // Verificar integridade b√°sica da chave
        const keyStart = credentials.private_key.trim().startsWith('-----BEGIN PRIVATE KEY-----');
        const keyEnd = credentials.private_key.trim().endsWith('-----END PRIVATE KEY-----');
        
        if (!keyStart || !keyEnd) {
          console.error('‚ùå Formato da chave privada parece inv√°lido!');
          console.error('‚ùå In√≠cio correto:', keyStart, 'Final correto:', keyEnd);
          throw new Error('Credenciais inv√°lidas - chave privada com formato inv√°lido');
        }
        
        // Mostrar um fingerprint seguro da chave (apenas primeiros e √∫ltimos caracteres)
        const keyLength = credentials.private_key.length;
        const firstChars = credentials.private_key.slice(0, 30);
        const lastChars = credentials.private_key.slice(-30);
        console.log(`üîë Fingerprint da chave (${keyLength} caracteres): ${firstChars}...${lastChars}`);
        
      } catch (fileError) {
        console.error('‚ùå Erro ao ler ou analisar o arquivo de credenciais:', fileError);
        throw new Error('Falha ao carregar credenciais do Google: ' + fileError.message);
      }

      // Configura a autentica√ß√£o JWT (Service Account)
      console.log('üîë Configurando autentica√ß√£o JWT');
      console.log('üîë Email da conta de servi√ßo:', credentials.client_email);
      const auth = new google.auth.JWT(
        credentials.client_email,
        null,
        credentials.private_key,
        [
          'https://www.googleapis.com/auth/spreadsheets',
          'https://www.googleapis.com/auth/drive',
          'https://www.googleapis.com/auth/drive.file'
        ]
      );
      
      // Cria a inst√¢ncia da API do Google Sheets
      const sheets = google.sheets({ version: 'v4', auth });
      console.log('‚úÖ Google Sheets API inicializada');
      
      // Adiciona teste de conex√£o de forma ass√≠ncrona
      const testConnection = async () => {
        try {
          console.log('üîç Testando acesso √† planilha...');
          const spreadsheetId = process.env.MODELO_SPREADSHEET_ID || '1czk_7v1yw-z4DDn79XoXAEJ4wkTT6hNxhfZOh053gZk';
          console.log('üîç ID da planilha:', spreadsheetId);
          console.log('üîç Projeto do Google Cloud:', credentials.project_id);
          console.log('üîç Client ID:', credentials.client_id);
          
          const testResponse = await sheets.spreadsheets.get({
            spreadsheetId: spreadsheetId
          });
          
          console.log('‚úÖ Teste de conex√£o bem-sucedido! T√≠tulo da planilha:', testResponse.data.properties.title);
          
          // Verificar se a aba "Sheet1" existe
          console.log('üîç Verificando se a aba "Sheet1" existe...');
          const sheetExists = testResponse.data.sheets.some(
            sheet => sheet.properties.title === 'Sheet1'
          );
          
          if (sheetExists) {
            console.log('‚úÖ Aba "Sheet1" encontrada com sucesso!');
          } else {
            console.error('‚ùå Aba "Sheet1" N√ÉO encontrada! Abas dispon√≠veis:');
            testResponse.data.sheets.forEach(sheet => {
              console.log(`- ${sheet.properties.title}`);
            });
            
            // Tentar criar a aba automaticamente
            console.log('üîß Tentando criar a aba "Sheet1" automaticamente...');
            try {
              await sheets.spreadsheets.batchUpdate({
                spreadsheetId: spreadsheetId,
                resource: {
                  requests: [
                    {
                      addSheet: {
                        properties: {
                          title: 'Sheet1',
                          gridProperties: {
                            rowCount: 1000,
                            columnCount: 25
                          }
                        }
                      }
                    }
                  ]
                }
              });
              
              // Adicionar cabe√ßalhos
              const headers = [
                'Timestamp', 
                'Anti-Stress', 
                'Anti-Stress (Outro)', 
                'Descontra√ß√£o', 
                'Descontra√ß√£o (Outro)',
                'Din√¢mica',
                'Din√¢mica (Outro)',
                'Elemento Surpresa',
                'Elemento Surpresa (Descri√ß√£o)',
                'Ponte',
                'Ponte (Descri√ß√£o)',
                'Lembran√ßa',
                'Lembran√ßa (Descri√ß√£o)',
                'Extras',
                'Nome',
                'Nome Art√≠stico',
                'Email',
                'Telefone',
                'Instagram',
                'Cidade'
              ];
              
              await sheets.spreadsheets.values.update({
                spreadsheetId: spreadsheetId,
                range: 'Sheet1!A1:T1',
                valueInputOption: 'USER_ENTERED',
                resource: {
                  values: [headers]
                }
              });
              
              console.log('‚úÖ Aba "Sheet1" criada com sucesso!');
            } catch (createError) {
              console.error('‚ùå Erro ao criar aba:', createError.message);
            }
          }
          
          // Testar inser√ß√£o de dados
          console.log('üîç Testando inser√ß√£o de dados...');
          try {
            const testData = ['Teste autom√°tico', new Date().toISOString(), 'Verifica√ß√£o de permiss√µes'];
            await sheets.spreadsheets.values.append({
              spreadsheetId: spreadsheetId,
              range: 'Sheet1!A:C',
              valueInputOption: 'USER_ENTERED',
              insertDataOption: 'INSERT_ROWS',
              resource: {
                values: [testData]
              }
            });
            console.log('‚úÖ Teste de inser√ß√£o bem-sucedido!');
          } catch (insertError) {
            console.error('‚ùå Erro ao testar inser√ß√£o:', insertError.message);
            if (insertError.errors) {
              console.error('Detalhes:', JSON.stringify(insertError.errors, null, 2));
            }
          }
        } catch (testError) {
          console.error('‚ùå Erro no teste de conex√£o:', testError.message);
          if (testError.status) console.error('‚ùå Status do erro:', testError.status);
          if (testError.errors) {
            console.error('‚ùå Detalhes do erro:', JSON.stringify(testError.errors, null, 2));
          }
          console.error('‚ùå Causa prov√°vel: a conta de servi√ßo n√£o tem acesso √† planilha');
          console.error('‚ö†Ô∏è Verifique se a conta de servi√ßo foi compartilhada com a planilha:');
          console.error(`‚ö†Ô∏è Email: ${credentials.client_email}`);
        }
      };
      
      // Executa o teste de conex√£o
      testConnection();
      
      return {
        sheets,
        SPREADSHEET_ID: process.env.MODELO_SPREADSHEET_ID || '1czk_7v1yw-z4DDn79XoXAEJ4wkTT6hNxhfZOh053gZk',
        SHEET_NAME: 'Sheet1'
      }
    } catch (error) {
      console.error('‚ùå Erro ao inicializar Google Sheets:', error);
      
      // Retorna um objeto mock que ir√° falhar graciosamente ao ser usado
      return {
        sheets: { 
          spreadsheets: { 
            values: { 
              append: async () => {
                throw new Error('Falha na configura√ß√£o do Google Sheets: ' + error.message);
              } 
            } 
          } 
        },
        SPREADSHEET_ID: '1czk_7v1yw-z4DDn79XoXAEJ4wkTT6hNxhfZOh053gZk',
        SHEET_NAME: 'Sheet1'
      }
    }
  } else {
    // Se n√£o estiver no server-side, retorna um mock para evitar erros durante o build
    console.warn('GoogleSheetsConfig: Tentando acessar no ambiente client-side')
    return {
      sheets: { spreadsheets: { values: { append: async () => ({ data: { updates: { updatedRows: 0 } } }) } } },
      SPREADSHEET_ID: 'mock-id',
      SHEET_NAME: 'mock-sheet'
    }
  }
} 